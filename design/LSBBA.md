# LSBBA: Local Sealed Bid Batch Auctions (name needs work) 

LSBBA is a fully on-chain sealed bid batch auction system built on the Axis Protocol that uses RSA encryption and a multi-step settlement process to avoid issues of previous sealed bid auction designs. The purpose of the system is to allow any seller to create sealed bid batch auctions for any ERC20 token pair. Sellers create an auction for a set amount of base tokens (capacity) and provide an RSA public key for buyers to encrypt their bids with. Buyers encrypt a portion of their bids (the amount out) off-chain using the RSA public key and submit them to the contract. The amount of quote tokens is public and the tokens they're bidding are sent to the contract on the bid. Once an auction ends, the settlement happens in two steps. First, the bids are decrypted off-chain, submitted to the contract, and verified by the contract. This can be done by anyone who has the RSA private key to decrypt the bids off-chain. If the Seller uses the Axis dapp to deploy a market, the RSA keypair is generated by an API and the private key is released after the auction concludes so that anyone can do the decryption. Once all the bids are decrypted, anyone can settle the auction and pay out proceeds to the winners. Those who do not win the auction can claim a refund following settlement.

## User Features

### Sellers
- Permissionlessly create sealed bid batch auctions, which improve execution over open bid auctions
- Auctions can be created for any ERC20 token pair
- Two transactions to create auction: 1. approve base token (if not already), 2. create auction
- Can limit auction participants using an allowlist
- Can use hooks to customize transfer logic for auction proceeds
- Can create and auction a derivative of the base token if desired
- Can enforce a minimum price and minimum capacity filled in order for auction to settle
- System is on-chain and transparent

### Buyers
- Permissionlessly place bids on any auction (assuming no allowlist)
- Bids are encrypted. Protocol key service hides private key from everyone, even sellers, so that no one can peek at your bids until after the auction is over.
- Settlement is permissionless
- System is on-chain and transparent

## Components and Design Decisions
This version of a sealed bid auction system has a few key properties that make it attractive:
1. Maximally Permissionless. The entire auction process happens on-chain and can be executed without relying on our off-chain infrastructure.
2. Transparent. All bids are encrypted and stored on-chain, but the bids are not decrypted until after the auction ends. This allows anyone to verify the bids and the settlement process.
3. Simple. As an early version of the system, we wanted to get something out that isn't too difficult to build.

However, the user experience is not as good as an off-chain or hybrid system could be. Specifically, users must submit transactions to bid, cancel a bid, and claim a refund if they do not win the auction. We plan for this system to only be used on chains where gas costs are low to mitigate the cost to both buyers and sellers. Additionally, because newer L2 chains don't have the same available of off-chain infrastructure and services as mainnet, it isn't possible to do some of the hybrid designs on these chains (e.g. web3 functions).

### Smart Contracts

#### Axis Protocol
Axis enables arbitrary auction and derivative combinations in a single settlement contract (the AuctionHouse). For this particular solution, there are only 3 contracts required.
  - Auction House
  - LSBBA (Auction Module)
  - Vesting Module

#### Permit2 Approvals
Gasless for buyers after initial approval
[Permit2](https://github.com/Uniswap/permit2): Signature-based approvals for any ERC20 token
  - [Integration Guide](https://blog.uniswap.org/permit2-integration-guide)

### Encryption Key Management
What: Need to be able to encrypt bids and other data with a key that no interested party controls until the auction ends. This is to prevent insider dealing or other bad behavior.

Solution: API and private database that creates RSA keypairs and store the private key until an auction ends. If an auction is cancelled, the private key is never released.

Axis will provide a simple API that provides key management for RSA keypairs generated on auction creation. The API will generate a new keypair and store the private key in a database. The public key is returned to the user and stored on the auction contract. Once the auction ends, the private key is released from the database and can be used to decrypt the bids. The API will also provide a convenience function for returning the next bids that need to be decrypted for a given auction. This will allow anyone to decrypt the bids and submit them to the contract for verification.

The API will be written in Rust and the database will be a MongoDB instance following the architecture of the Bond Protocol Limit Orders system. This can be easily hosted on Railway and provides good CI/CD support.

In addition to the API, there will be a Rust service that watches for new auction creation events, checks whether the API provided the key, and stores the auction ID and conclusion timestamp in the database. This will allow the API to release the private key at the correct time. We need this service since we cannot be sure of the auction ID when a key is generated (it may be front-run by another transaction, for example).

### UI / dApp
We will provide a user interface (aka dApp) for both Sellers and Buyers to interact with the product. The key user actions are defined below in the Actions section. The core pages we be:
- List of auctions (TBD on design and filtering between statuses)
- Create auction page - for sellers to create new auctions
- Auction page - Details the status and available actions for a given auction. The auction page will need to support these differents states:
  - Created - Auction has been created, but not started
  - Live - Auction is created and currently accepting bids. Buyers should be able to bid and cancel bids they have made.
  - Concluded - Auction has ended and bids are being decrypted. Anyone should be able to decrypt the bids and submit them to the contract for verification.
  - Decrypted - Bids are decrypted and awaiting settlement. Anyone should be able to settle the auction.
  - Settled - Auction payouts have been issued. Buyers that did not win can claim refunds.

The architecture will be a Single Page App (SPA) hosted on [IPFS](https://docs.ipfs.tech/how-to/websites-on-ipfs/single-page-website/) with [Eth.limo](https://eth.limo/) domain resolution to ENS owned by the protocol.

#### Subgraph
In order to display user bids on the dapp, it is most convenient to use a subgraph to index the bids from events emitted from the smart contracts. Therefore, we will need to create a subgraph for the AuctionHouse (and possibly other modules depending on where the events reside).

## Actions

### Seller Creates Auction
A seller creating an auction is the first step in the lifecycle. They provide common auction parameters as well as auction specific parameters to the AuctionHouse contract to kick it off. They must approve the AuctionHouse for the token they are selling (base token) or provide a Hooks contract that will settle the auction 

```mermaid
sequenceDiagram
  autoNumber
  participant Seller
  participant UI
  participant API
  participant Database
  participant AuctionHouse
  participant LSBBA
  participant Watcher

  Seller->>UI: Navigate to Create Auction page
  activate UI
    Seller->>UI: Input auction data (baseToken, quoteToken, start, duration, minPrice, capacity, optionally hooks, allowlist, and derivative data)
    Seller->>UI: Click "Create Auction"
    UI->>API: Request new RSA keypair
    activate API
        API->>API: Generate new RSA keypair
        API->>Database: Store private key
        API-->UI: Return public key
    deactivate API
    UI->>UI: Create transaction to create auction with input data + public key
    UI-->Seller: Present transaction to Seller to sign
    Seller->>UI: Sign transaction to create auction
    UI->>AuctionHouse: Send transaction to blockchain
    activate AuctionHouse
        AuctionHouse->>AuctionHouse: Validate and store routing & derivative parameters
        AuctionHouse->>LSBBA: Call auction module with auction params and lot ID
        activate LSBBA
            LSBBA->>LSBBA: Validate and store auction parameters
            LSBBA-->AuctionHouse: Hand execution back to AuctionHouse
            LSBBA-->Watcher: Emit event for auction creation with public key
            Watcher->>Database: Store auction ID and conclusion timestamp for public key
        deactivate LSBBA
        AuctionHouse-->UI: Finish execution and return result
    deactivate AuctionHouse
    UI-->Seller: Show transaction status
  deactivate UI
```

### Buyer Places Bid
```mermaid
sequenceDiagram
  autoNumber
  participant Buyer
  participant UI
  participant Permit2
  participant AuctionHouse
  participant LSBBA

  Buyer->>UI: Navigate to Auction page
  UI->>AuctionHouse: Fetch data for auction ID (base token, quote token, public key, start, conclusion, auction type, derivative type + info, capacity, min bid size)
  AuctionHouse->>LSBBA: Get data stored on module to return
  AuctionHouse-->UI: Return results
  UI-->Buyer: Display data for user
  Buyer->>UI: Input bid data (amount, minAmountOut)
  UI->>Permit2: Check user's approval for quote token
  alt user hasn't approved Permit2
    UI-->Buyer: Display "Approve Permit2" button
    Buyer->>UI: Click "Approve Permit2" button
    UI-->Buyer: Display transaction for signing
    Buyer->>UI: Sign approval transaction
    UI->>Permit2: Send approval transaction
    Permit2-->UI: Return execution result
  end
  UI-->Buyer: Display "Place bid" button
  Buyer->>UI: Click "Place bid" button
  UI->>UI: Get random seed for encryption
  UI->>UI: Encrypt minAmountOut with public key from auction
  UI->>UI: Construct permit2 approval for AuctionHouse
  UI-->Buyer: Display permit2 signature request
  Buyer->>UI: Sign permit2 signature request
  UI->>UI: Create bid transaction with permit2 approval and bid data (amount, encrypted minAmountOut)
  UI-->Buyer: Display transaction for signing
  Buyer->>UI: Sign bid transaction
  UI->>AuctionHouse: Send bid transaction to blockchain
  activate AuctionHouse
    AuctionHouse->>AuctionHouse: Validate permit2 approval and transfer quote tokens
    AuctionHouse->>LSBBA: Call bid function with auction ID, amount, and encrypted minAmountOut
    activate LSBBA
        LSBBA->>LSBBA: Validate bid parameters and store encrypted bid data
        LSBBA-->AuctionHouse: Hand execution back to AuctionHouse
    deactivate LSBBA
    AuctionHouse-->UI: Return transaction result
  deactivate AuctionHouse
  UI-->Buyer: Display submission result to user
```

### Buyer Cancels Bid
Buyers are able to cancel bids they make prior to the auction concluding and receive their deposit back. The bid must be deleted from the stored bids so as to not require it to be decrypted.

```mermaid
sequenceDiagram
  autoNumber
  participant Buyer
  participant UI
  participant AuctionHouse
  participant LSBBA
  participant Subgraph

  Buyer->>UI: Navigate to Auction page
  UI->>AuctionHouse: Fetch data for auction ID (base token, quote token, public key, start, conclusion, auction type, derivative type + info, capacity, min bid size)
  UI->>Subgraph: Fetch bids for user on auction ID
  UI-->Buyer: Display bids for user
  Buyer->>UI: Click "Cancel bid" button
  UI->>AuctionHouse: Send `cancelBid(lotId, bidId)` transaction to blockchain.
  activate AuctionHouse
    Note over AuctionHouse: Not exactly sure the separation of duties between module and AuctionHouse yet
    AuctionHouse->>AuctionHouse: Validate and delete bid, if it exists
    AuctionHouse->>LSBBA: Call cancelBid function with auction ID and bid ID
    activate LSBBA
        LSBBA->>LSBBA: Validate and delete bid (ensuring that it doesn't mess up settlement)
        LSBBA-->AuctionHouse: Hand execution back to AuctionHouse
    deactivate LSBBA
    AuctionHouse-->UI: Return transaction result
  deactivate AuctionHouse
  UI-->Buyer: Display transaction result and update bids
```

### Seller Cancels Auction
Sellers are able to specify a start time for their auction in the future. If they want to cancel the auction before it starts, they can do so and the auction will be deleted. If the auction has already started and is accepting bids, then the seller can no longer cancel it.

```mermaid
sequenceDiagram
  autoNumber
  participant Seller
  participant UI
  participant AuctionHouse
  participant LSBBA
  participant Watcher

  Seller->>UI: Navigate to Auction page
  UI->>AuctionHouse: Fetch data for auction ID (base token, quote token, public key, start, conclusion, auction type, derivative type + info, capacity, min bid size)
  UI-->Seller: Display auction data
  Seller->>UI: Click "Cancel auction" button
  UI->>AuctionHouse: Send `cancelAuction(lotId)` transaction to blockchain.
  activate AuctionHouse
    AuctionHouse->>AuctionHouse: Validate and delete auction
    AuctionHouse->>LSBBA: Call cancelAuction function with auction ID
    activate LSBBA
        LSBBA->>LSBBA: Validate and delete auction
        LSBBA-->AuctionHouse: Hand execution back to AuctionHouse
        LSBBA-->Watcher: Emit event for auction cancellation
        Watcher->>Watcher: Get auction ID from event
        Watcher->>Database: Delete auction ID and conclusion timestamp for public key
    deactivate LSBBA
    AuctionHouse-->UI: Return transaction result
  deactivate AuctionHouse
  UI-->Seller: Display transaction result and update auction status
```


### Auction Settlement Part 1: Decryption
After an auction has concluded, the bids must be decrypted and sorted by price. We do this by releasing the RSA private key from the database via the API to anyone on the dapp looking at the auction page. Decryption works by providing an array of (amountOut, seed) for the bids in the order they were submitted to the contract. The seed was randomly generated on submission and can be extracted by decrypting the bid. The API provides a convenience function for returning an array for the next bids that need to be decrypted from an auction (using its ID). It may take several decryption transactions depending on the number of bids and gas limit. Once, all bids are decrypted on the contract, we can move to part 2 of the settlement process.

Note: this requires direct transactions to the LSBBA auction module since the `decryptBids` function is not generic and won't be on the AuctionHouse

```mermaid
sequenceDiagram
  autoNumber
  participant User
  participant UI
  participant API
  participant Database
  participant LSBBA

  User->>UI: Navigate to Auction page
  UI-->User: Display auction status and percent of bids decrypted
  User->>UI: Click "Decrypt bids" button
  UI->>API: Request next bids to decrypt for auction ID
  activate API
      API->>Database: Get private key for auction ID
      API->>LSBBA: Get encrypted bids and nextDecryptId for auction ID
      activate LSBBA
          LSBBA->>LSBBA: Get encrypted bids for auction ID
          LSBBA-->API: Return encrypted bids
      deactivate LSBBA
      API->>API: Decrypt bids
      API-->UI: Return array of decrypted bids
  deactivate API
  UI->>UI: Create transaction to decrypt bids with array
  UI-->User: Display transaction for signing
  User->>UI: Sign transaction to decrypt bids
  UI->>LSBBA: Send transaction to blockchain
  activate LSBBA
      LSBBA->>LSBBA: Validate and store decrypted bids
      alt all bids decrypted
          LSBBA->>LSBBA: Set auction status to "decrypted"
      end
      LSBBA-->UI: Return transaction result
  deactivate LSBBA
  UI-->User: Display transaction result and update auction status
```

### Auction Settlement Part 2: Evaluate winners and send proceeds
The final step to settle an auction is to evaluate the sorted, decrypted bids to determine the marginal price for the auction and distribute funds to the winners. If the auction did not reach the minimum price or minimum fill capacity, then the auction is settled without winners, and users can claim refunds. If there are winners, then they are paid out the base tokens (or derivative) and the seller receives the proceeds. Users that do not win must claim a refund. The settlement function is open and can be called by anyone after the decryption process is complete.

```mermaid
sequenceDiagram
  autoNumber
  participant User
  participant UI
  participant AuctionHouse
  participant LSBBA
  participant VestingModule
  participant Seller
  participant Buyers

  User->>UI: Navigate to Auction page
  UI-->User: Display auction status
  User->>UI: Click "Settle auction" button
  UI-->User: Display transaction for signing
  User->>UI: Sign transaction to settle auction
  UI->>AuctionHouse: Send transaction to blockchain
  activate AuctionHouse
      AuctionHouse->>AuctionHouse: Validate auction status and settle auction
      AuctionHouse->>LSBBA: Call settle function with auction ID
      activate LSBBA
          LSBBA->>LSBBA: Validate auction status and settle auction
          alt auction did not reach minimum price or capacity
              LSBBA->>LSBBA: Set auction status to "settled"
          else auction reached minimum price and capacity
              LSBBA->>LSBBA: Set auction status to "settled"
              LSBBA->>LSBBA: Calculate marginal price
              LSBBA->>LSBBA: Distribute proceeds to winners
              LSBBA->>LSBBA: Distribute refunds to losers
          end
          LSBBA-->AuctionHouse: Hand execution back to AuctionHouse
      deactivate LSBBA
      AuctionHouse->>AuctionHouse: Collect fees
      alt seller specified hook for proceeds
          AuctionHouse->>Seller: Call hook with proceeds
          Seller->>Seller: Execute hook logic
          Seller-->AuctionHouse: Send base tokens and return execution to AuctionHouse
      else
          Seller-->AuctionHouse: Base tokens transferred from Seller to AuctionHouse
      end
      alt payout is a derivative of base token
        AuctionHouse->>VestingModule: Mint vesting tokens to winners
        VestingModule-->Buyers: Send vesting tokens to winners
      else
        AuctionHouse-->Buyers: Send payouts to winners
      end
      AuctionHouse->>AuctionHouse: Set auction status to "settled"
      AuctionHouse-->UI: Return transaction result
  deactivate AuctionHouse
  UI-->User: Display transaction result and update auction status
```

